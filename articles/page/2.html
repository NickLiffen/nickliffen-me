<!doctype html>
<html lang="en">
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZG0XYVVEZW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZG0XYVVEZW');
</script>
  <meta charset="utf-8">
  <title>Nick Liffen's Blog | Technology, DevOps and Dev Blog | Page 2</title>
  <meta name="description" content="Nick Liffen's Blog | Focusing on DevOps, Developer Experience and all aspects of Technology">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="Nick Liffen">
  <meta property="og:title" content="Nick Liffen's Blog | Technology, DevOps and Dev Blog | Page 2">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://nickliffen.dev/articles/page/2.html">
  <meta property="og:image" content="https://nickliffen.dev/">
  <meta name="keywords" content="Nick, Liffen, JavaScript, Blog">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@nickliffen">
  <meta name="twitter:creator" content="@nickliffen">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://www.googletagmanager.com https://www.google-analytics.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self' https://www.google-analytics.com https://*.google-analytics.com https://*.analytics.google.com;">

  <link rel="canonical" href="https://nickliffen.dev/articles/page/2.html">
  <link rel="shortcut icon" href="../../favicon.ico">
  <link rel="manifest" href="../../manifest.webmanifest" crossorigin="use-credentials">
  <link rel="apple-touch-icon" href="../../icon.png">
  <link rel="alternate" type="application/rss+xml" title="Subscribe to What's New" href="https://nickliffen.dev/rss.xml" />
  <link rel="stylesheet" type="text/css" href="../../css/poole.css">
  <link rel="stylesheet" type="text/css" href="../../css/hyde.css">

  <meta name="theme-color" content="#fafafa">
  <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Blog",
  "@id": "https://nickliffen.dev/articles/page/2.html",
  "name": "Nick Liffen's Blog | Technology, DevOps and Dev Blog | Page 2",
  "headline": "Nick Liffen's Blog | Technology, DevOps and Dev Blog | Page 2",
  "description": "Nick Liffen's Blog | Focusing on DevOps, Developer Experience and all aspects of Technology",
  "datePublished": "2021-01-30",
  "dateModified": "2021-02-14",
  "keywords": [
    "Blog",
    "Technology",
    "DevOps",
    "Nick",
    "Liffen",
    "Developer",
    "GitHub"
  ],
  "url": "https://nickliffen.dev/articles/page/2.html",
  "author": {
    "@type": "Person",
    "name": "Nick Liffen"
  },
  "blogPosts": [
    {
      "@type": "BlogPosting",
      "@id": "https://nickliffen.dev/articles/step-functions.html",
      "name": "Nick Liffen's Blog | Coordinating a multi-lambda software product | Blog Post",
      "headline": "Let's discuss the value of Step Functions by sharing a real life example.",
      "description": "Nick Liffen's Blog | Coordinating a multi-lambda software product | Blog Post",
      "image": "https://nickliffen.dev/img/ghas.png",
      "datePublished": "2021-08-29",
      "dateModified": "2021-08-29",
      "keywords": [
        "Nick",
        "Liffen",
        "Software",
        "Lambda",
        "Step Functions"
      ],
      "articleSection": [
        "Context",
        "Model One - SQS",
        "Model One - Step Functions",
        "Going into Detail about Step Functions",
        "Conclusion"
      ],
      "articleBody": "...",
      "url": "https://nickliffen.dev/articles/step-functions.html",
      "author": {
        "@type": "Person",
        "name": "Nick Liffen"
      },
      "publisher": {
        "@type": "Person",
        "name": "Nick Liffen"
      }
    },
    {
      "@type": "BlogPosting",
      "@id": "https://nickliffen.dev/articles/centralised-vs-innersourcing-devops.html",
      "name": "Nick Liffen's Blog | An InnerSourcing Approach within an Enterprise | Blog Post",
      "headline": "Let's discuss the value of InnerSoucing by sharing a real life example.",
      "description": "Nick Liffen's Blog | An InnerSourcing Approach within an Enterprise from Eli Lilly on InnerSourcing | Blog Post",
      "image": "https://nickliffen.dev/img/innersourcing.png",
      "datePublished": "2021-02-13",
      "dateModified": "2021-02-13",
      "keywords": [
        "Nick",
        "Liffen",
        "InnerSourcing",
        "Blog",
        "Enterprise"
      ],
      "articleSection": [
        "Context",
        "What does centralisation mean?",
        "What does decentralisation mean?",
        "So, what one should we pick?",
        "Conclusion"
      ],
      "articleBody": "...",
      "url": "https://nickliffen.dev/articles/innersourcing.html",
      "author": {
        "@type": "Person",
        "name": "Nick Liffen"
      },
      "publisher": {
        "@type": "Person",
        "name": "Nick Liffen"
      }
    }
  ]
}
</script>
</head>

<body>
  <a href="#main-content" class="skip-link" style="position:absolute;left:-10000px;top:auto;width:1px;height:1px;overflow:hidden;" onfocus="this.style.left='0';this.style.width='auto';this.style.height='auto';" onblur="this.style.left='-10000px';this.style.width='1px';this.style.height='1px';">Skip to main content</a>
  <div class="sidebar">
    <div class="container sidebar-sticky">
      <div class="sidebar-about">
        <h1>Nick Liffen</h1>
        <p class="lead">This is where I share my experiences</p>
      </div>
      <nav aria-label="Main navigation">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-item active">
          <a href="/">Home</a>
        </li>
        <li class="sidebar-nav-item">
          <a href="https://github.com/nickliffen">GitHub Profile</a>
        </li>
      </ul>
      </nav>
      <p>&copy; 2025. All rights reserved.</p>
    </div>
  </div>

  <main id="main-content" class="content container">
    <h1 class="center post-title mb">Table of Contents</h1>
    <div class="center mb">
      <div class="margin"><a href="../leadership-principles.html"> Leadership Principles: Guiding the Way to Success</a></div>
      <div class="margin"><a href="../why-advanced-security.html">Why Advanced Security?</a></div>
      <div class="margin"><a href="../developer-evolution.html">The Importance of Developer Experience - Developer roles are evolving!</a></div>
      <div class="margin"><a href="../step-functions.html">Coordinating a multi-lambda software product</a></div>
      <div class="margin"><a href="../innersourcing.html">An InnerSourcing Approach within an Enterprise</a></div>
      <div class="margin"><a href="../centralised-vs-decentralised-devops.html">Centralised vs Decentralised DevOps Toolchain - The Differences</a></div>
      <div class="margin"><a href="../review-ghas-code-scanning-enterprise.html">Review of GitHub Advanced Security Code Scanning in an Enterprise (Part 1)</a></div>
      <div class="margin"><a href="../building-a-simple-website.html">Building a simple website</a></div>
    </div>
    <hr class="rounded">
    <div class="posts">
      <div class="post">
        <h1 class="post-title mb">
            Coordinating a multi-lambda software product
        </h1>
        <span class="post-date">29th Aug 2021</span>
        <h2 id="introduction" class="mb">Introduction:</h2>
        <p>The more I have been working on AWS, the more I understanding the importance of well-architected solutions. Today, I would like to focus on the value of <a href="https://aws.amazon.com/step-functions/?step-functions.sort-by=item.additionalFields.postDateTime&step-functions.sort-order=desc" target="_blank" rel="noopener noreferrer">AWS Step Functions</a>. What are Step Functions? The offical description is: </p> 
        <p><em>
          AWS Step Functions is a low-code visual workflow service used to orchestrate AWS services, automate business processes, and build serverless applications. Workflows manage failures, retries, parallelization, service integrations, and observability so developers can focus on higher-value business logic.
        </em></p>
        <p>To explain the value, I am going to use some hypothetical use cases, which are:</p>
        <ul>
            <li><strong>Use Case One:</strong> As a GitHub administrator, whenever a new developer joins the GitHub organisation, I would like to add them to a GitHub Team so that they can access repositories straight away. I also would like to fetch internal company information about that user (email, id, etc.) and add them to an internal DB for querying.</li>
            <li><strong>Use Case Two:</strong> As a GitHub administrator, whenever a GitHub Workflow completes, I would like to calculate the workflow cost and work out the total workflow count for the repository, so it's easy to do chargebacks per repository. I also would like to store the data in a DB so it can be queried historically.</li>
        </ul>
        <p>Before we build out some architectures, let's set some principles:</p>
        <ul>
            <li><strong>Purposeful:</strong> Single function lambda's for single-use cases. (not combining multiple businesslogic into a single lambda). This is to promote reuse.</li>
            <li><strong>Event Driven:</strong> No polling or waiting on a cron which triggers to see if things have changed. I would like an end-to-end event driven architecture.</li>
            <li><strong>Stateful:</strong> Non-Invoke Based (Callback hell). E.G Lambda A Invoked Lambda B from within Lambda A and waits for Lambda B to be done to return success/fail</li>
        </ul>
        <p> Now, as with any architecture, there are multiple ways to build out this example system. I will show two examples below and compare & contrast the pros and cons of each, mainly focusing on how to use multiple lambdas together and why AWS Step Functions are beneficial.  </p>
        <h2 id="sqs" class="mb">Model One - SQS:</h2>
        <img src="./img/sqs.png" alt="AWS SQS Arch Design" style='height: 100%; width: 100%; object-fit: contain' loading="lazy">
        <p>Let's walk through the above diagram. We have a GitHub App configured on two events (A, B). We use a GitHub App to remove the "human" element of the connection, along with some other goodies like an increase in API Requests. The GitHub App will send a payload to our API, but before it reached the API, we use AWS Route 53 for our custom DNS record, which then will proxy down to our AWS Cloudfront Distribution. </p>
        <p>Once the payload reaches the API, we will first use the direct integration between AWS HTTP API Gateways and AWS Lambda to first process the data. Then, to communicate between the rest of the lambdas, we use AWS SQS to traffic data between lambdas for processing. Finally, data ends up in the database where you could use a service like AWS AppSync or another API Gateway to fetch the data.  </p>
        <p>Let's talk about the pros:</p>
        <ul>
            <li><strong>Extensible:</strong> It's extensible, as an individual SQS Queue fronts each function. Meaning, you're able to quickly send data to that function from any service that can send structured data. You may know about Lambda X needing to send data to Lambda Y. Still when a new Lambda comes in, Lambda Z, it's easy to add that lambda into the current architecture and send data to Lambda Y without breaking the current pattern.</li>
        </ul>
        <p>Let's talk about the cons:</p>
        <ul>
            <li><strong>Clean Arch:</strong> It's a little messy. I am a big believer that most clean architectures are simple. Don't overcomplicate something and add AWS services because it could fit a need. Look at alternatives to reduce your footprint. There are 6 SQS Queues; they seem to be the most predominant service in this design. Are they needed? </li>
            <li><strong>Problem Finding:</strong> How easy is it to <strong>really</strong> find problems? We have a dead letter queue configured so any messages that don't complete can be re-processed accordingly, but you only see a problem at a time; you don't see the history of where that data has come from or where it has been or how it has been processed. You would have to write some custom code to do this. </li>
            <li><strong>App Tracking:</strong> Amazon SQS requires you to implement application-level tracking, especially if your application uses multiple queues, which in this case, it does. </li>
        </ul>
        <p> Overall, this isn't a bad architecture, it fits a use case, but could it be fine-tuned?</p>
        <h2 id="sf" class="mb">Model Two - Step Functions</h2>
        <img src="./img/sf.png" alt="AWS Step Functions Arch Design" style='height: 100%; width: 100%; object-fit: contain' loading="lazy">
        <p>Both ingress patterns into AWS are the same. The main difference starts when you get past the AWS HTTP API Gateway and into the data processing. </p>
        <p>As this solution has multiple lambdas, we use AWS Step Functions to coordinate how they interact. So, when a payload reaches the HTTP API, we trigger the AWS Step function. Data is processed by each lambda and sent back to the state machine, where finally it inserts data into the DB and uses a custom AWS SNS Topic to send an email on success/error. </p>
        <p>Both have similar architectures but differ slightly in data communication; let's discuss the detail ... </p>
        <p>Let's talk about the pros:</p>
        <ul>
            <li><strong>Less Code:</strong> We don't have to write a custom lambda to enter data into the DB. Step functions have a native integration with DynamoDB, meaning we don't have to write code to do something preexisting. More information on integrations can be found here: <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-service-integrations.html" target="_blank" rel="noopener noreferrer">Using AWS Step Functions with other services</a>.</li>
            <li><strong>Less AWS Resource(s):</strong> No need for any queues. We use the state machine to send data to the following lambda in the chain. More information on how to send data within step functions can be found here: <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-data.html" target="_blank" rel="noopener noreferrer">State Machine Data</a></li>
            <li><strong>Process Overview:</strong> Easy to see the whole process in action. Step Functions easy allow you to see the data that is processing. To see more information on seeing the overall process, check out this link: <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-input-output-filtering.html" target="_blank" rel="noopener noreferrer">Input and Output Processing in Step Functions</a></li>
            <li><strong>Easy to find problems:</strong> Don't you dislike having to crawl through cloudwatch events to find errors logged out from a lambdas console? Using AWS Step Functions allows you to quickly find errors via the Step Functions GUI as you can crawl through the state machines events to find problems. I find this link really useful for more information on debugging: <a href="https://docs.aws.amazon.com/step-functions/latest/dg/monitoring-logging.html" target="_blank" rel="noopener noreferrer">Monitoring &amp; Logging</a></li>
            <li><strong>Built in retries:</strong> Sometimes lambdas error and writes into DynamoDB's fail. Although they are rare, if not handled correctly, they could cause downstream dilemmas. Step Functions have inbuilt retry capabilities that allow you to retry on specific errors. Meaning you can only retry on specific event errors that you would like to retry on. More information on this can be found here: <a href="https://aws.amazon.com/blogs/developer/handling-errors-retries-and-adding-alerting-to-step-function-state-machine-executions/" target="_blank" rel="noopener noreferrer">Monitoring &amp; Logging</a></li>
        </ul>
        <p>Let's talk about the cons:</p>
        <ul>
            <li><strong>Con One:</strong> Step Functions has some pretty strict and small <a href="https://docs.aws.amazon.com/step-functions/latest/dg/limits-overview.html" target="_blank" rel="noopener noreferrer">limits</a> (I actually think this article is a nice summary of the limits: <a href="https://docs.aws.amazon.com/step-functions/latest/dg/monitoring-logging.html" target="_blank" rel="noopener noreferrer">Think Twice Before Using Step Functions â€” Check the AWS Serverless Service Quotas</a>). If you are processing lots of data, you would need to split your step functions into multiple state machines. One idea on how to architect your solution around this limit is to create a parent/child sate machine. E.G, a child state machine could process a single data entry at a time, which invokes from a parent state machine that loops through the data, but doesn't directly <strong>do</strong> any of the processing, so it stays within limits. </li>
            <li><strong>Con Two:</strong> If another system needs to reuse a specific function, there is no queue in front of it, making it harder to call. Making the architecture not amazingly extensible. Yes, you can still use AWS SQS with step functions, but unless you think it's needed externally to this use case, it likely isn't required. </li>
        </ul>
        <p> Overall, I genuinely believe this architecture is cleaner and runs a more robust process than the previous design. </p>
        <h2 id="sf-detail" class="mb">Going into detail about Step Functions</h2>
        <p>I would like to focus on two core parts of step functions that stand out to me:</p>
        <h3>Feature One: Built in looping through arrays</h3>
        <p>Let's say you have a data set of 1,000 users. You <i>could</i> send all 1,000 users to the lambda via an SQS Queue (but you can only send ten records at a time, remember), loop through all users, process them accordingly and send them back to the state machine. Or, you could use the inbuilt <a href="https://docs.aws.amazon.com/step-functions/latest/dg/amazon-states-language-map-state.html" target="_blank" rel="noopener noreferrer">map</a> feature within Step Functions that will map through the user's array at the sate machine level and send one user record at a time to the lambda for processing. Why would you do this? It allows you to write less code within your lambda, fewer loops, hopefully, quicker processing. In my opinion, it also makes your code cleaner. </p>
        <p>It looks a little like this within the state machine definition file:</p>
        <pre>
Invoke Worker State Machine:
Type: Map
InputPath: "$.users"
MaxConcurrency: 50
Parameters:
    UserDetails.$: "$$.Map.Item.Value"
        </pre>
        <h3>Feature Two: AWS Step Functions can call AWS Step Functions</h3>
        <p>As mentioned above, AWS Step Functions have some pretty strict (and small) limits. Meaning you have to architect your solutions correctly. An elegant aspect of Step Functions is they can call other <a href="https://docs.aws.amazon.com/step-functions/latest/dg/sample-start-workflow.html" target="_blank" rel="noopener noreferrer">step functions</a>. Meaning if you have been processing lots of data and are reaching limits, you can split up your Step Function into one parent step function, and then a child step function where you send one data record at a time to be processed individually from the parent.</p>
        <p>It looks a little like this within the state machine definition file:</p>
        <pre>
Iterator:
StartAt: Invoke Worker State Machine Task
States:
    Invoke Worker State Machine Task:
    Type: Task
    Resource: arn:aws:states:::states:startExecution.sync:2
    Parameters:
        StateMachineArn: "${ChildStateMachineArn}"
        Input:
        UserDetails.$: "$.UserDetails"
        AWS_STEP_FUNCTIONS_STARTED_BY_EXECUTION_ID.$: "$$.Ex.Id"
        </pre>
        <p>Taking the above two code snippets, you are looping through the user's array of objects and sending one user at a time. Let's say you have 1,000 users; you are spinning up 1,000 child step functions and processing one user at a time. </p>
        <p> These are just two features that I think make Step Functions a great resource to use when co-ordinating a multi-lambda solution. However, there are so many more, check out the following docs for more information <a href="https://docs.aws.amazon.com/step-functions/latest/dg/welcome.html" target="_blank" rel="noopener noreferrer">Introduction to AWS Step Functions</a></p>
        <h2 id="conclusion" class="mb">Conclusion</h2>
        <p>I have found Step Functions to be a great resource when working across lambdas. They give you more confidence in your design and allow you to write less code, and in most cases, less code is better code, right? </p>
      </div>
      <hr class="rounded">
      <div class="post">
        <h1 class="post-title mb">
          An InnerSourcing Approach within an Enterprise
        </h1>
        <span class="post-date">14th Feb 2021</span>
        <h2 id="context" class="mb">Context:</h2>
        <p>InnerSourcing. An approach that could revolutionise software development within enterprises, yet an approach unknown to most. So, what is InnerSourcing? Most people/companies have different interpretations, but overall, InnerSourcing takes the values and principles of "open source" and looks to apply that within an enterprise. Traditionally, software teams are siloed and have their objectives, meaning they are focused on their deliverables and nothing else. Typically, if these teams were to take a step back and look across the enterprise, they would see other teams trying to do the same thing, or even better, other teams have solved/come up with a solution already. What InnerSourcing tries to achieve is collaboration across teams to meet a common goal. Why have multiple teams work on the same thing separately, versus combining everyone's knowledge in these teams to work together to meet the outcome as one. </p>
        <h2 id="advantages" class="mb">Advantages:</h2>
        <p>InnerSourcing has some more values than just cross-team collaboration; some more advantages are:</p>
        <ul>
          <li><strong>Faster development:</strong> Having multiple developers from various teams will lead to faster development, versus a single team where only one or two developers may be focused on that deliverable.</li>
          <li><strong>Documentation:</strong> If multiple teams are consuming a software product, more focus is put on writing good documentation. This is so developers looking to use the software product can get up and running quickly, rather than figure it out themselves.</li>
          <li><strong>Code Reuse:</strong> It is better to build once and reuse multiple times, then build several times and use once. This is because code is more maintainable as if an update needs to be made, it gets made once, versus every team needing to make the same change.</li>
          <li><strong>Encourage innovation:</strong> Innersourcing gets more minds on the same outcome. Naturally, this means a more diverse mindset, leading to a broader range of solutions being proposed to a problem; therefore, you encourage innovation. </li>
          <li><strong>Healthy Competition:</strong> The more advanced companies create healthy competition by rewarding developers who have "InnerSourced" the most. Doing this gets the most out of your developers and keeps them engaged.</li>
          <li><strong>Security &amp; Quality:</strong> This is one of the more unrecognised values. Building something once and reusing it multiple times means if an urgent security vulnerability needs to be patched, the update just needs to be made to a single codebase. The teams using the fixed software need to do nothing. On the next release of their software, it will get automatically pulled down and patched.</li>
        </ul>
        <p>These are just a few examples to show why InnerSourcing can be such a success within enterprises. </p>
        <h2 id="success-story" class="mb">Success Story</h2>
        <p>At this point (traditionally) in my blog, I would usually explain how something works and share my experience/further thoughts on the topic. However, for this article, I would like to link out to a conference I spoke at back in 2018.</p>
        <p>Every year, GitHub host a conference in San Francisco called "GitHub Universe". This conference focuses on all aspects of software development, where GitHub and companies present approaches and best practices. I was lucky enough to present on behalf of Lilly, to talk about Lillys's InnerSourcing journey and the value seen internally. I discuss the concepts of InnerSourcing, the approach taken, some statistics of adoption, then ending with some best practices and tips &amp; tricks for other companies looking to adopt the same.</p>
        <p>See the video below:</p>
        <iframe class="video" src="https://www.youtube.com/embed/L19lgbIPQZs" title="Lilly's InnerSourcing Journey" loading="lazy" allowfullscreen="true"></iframe>
        <h2 id="conclusion" class="mb">Conclusion</h2>
        <p>To conclude, similar to DevOps, InnerSourcing can be seen as an approach and methodology to transform IT enterprises' traditional culture and behaviours. It helps to have a central team spearheading the journey, as that team can focus on automating the process which sparks and enables InnerSourcing. Additionally, it also helps to share and use the same suite of DevOps Tools (such as source code and package manager tools), as this removes friction in the developer experience. Asking a developer to go between multiple tools will lead to developer frustration and therefore, a lower appetite to adopt InnerSourcing. Developer experience has to be at the heart and focal point of a companies InnerSourcing journey.</p>
        <p>DevOps and InnerSourcing, although different, complement each other more then people realise. If companies lay solid foundations for one, it will naturally help lay the other's foundations, even if unintentional. Finally, I believe InnerSourcing will soon be the "norm" and a core approach for how software development occurs within enterprises. I am excited to see InnerSourcing grow and mature through various companies in the coming years. </p>
      </div>
    </div>
    <div class="pagination">
      <a href ="/"><span class="pagination-item older">Older</span></a>
      <a href ="/articles/page/3.html"><span class="pagination-item newer">Newer</span></a>
    </div>
    </main>
</body>

</html>
