<!doctype html>
<html lang="en">
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZG0XYVVEZW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZG0XYVVEZW');
</script>
  <meta charset="utf-8">
  <title>Nick Liffen's Blog | Technology, DevOps and Dev Blog | Page 3</title>
  <meta name="description" content="Nick Liffen's Blog | Focusing on DevOps, Developer Experience and all aspects of Technology">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="Nick Liffen">
  <meta property="og:title" content="Nick Liffen's Blog | Technology, DevOps and Dev Blog | Page 3">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://nickliffen.dev/articles/page/2.html">
  <meta property="og:image" content="https://nickliffen.dev/">
  <meta name="keywords" content="Nick, Liffen, JavaScript, Blog">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@nickliffen">
  <meta name="twitter:creator" content="@nickliffen">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://www.googletagmanager.com https://www.google-analytics.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self' https://www.google-analytics.com https://*.google-analytics.com https://*.analytics.google.com;">

  <link rel="canonical" href="https://nickliffen.dev/articles/page/3.html">
  <link rel="shortcut icon" href="../../favicon.ico">
  <link rel="manifest" href="../../manifest.webmanifest" crossorigin="use-credentials">
  <link rel="apple-touch-icon" href="../../icon.png">
  <link rel="alternate" type="application/rss+xml" title="Subscribe to What's New" href="https://nickliffen.dev/rss.xml" />
  <link rel="stylesheet" type="text/css" href="../../css/poole.css">
  <link rel="stylesheet" type="text/css" href="../../css/hyde.css">

  <meta name="theme-color" content="#fafafa">
  <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Blog",
    "@id": "https://nickliffen.dev/articles/page/2.html",
    "name": "Nick Liffen's Blog | Technology, DevOps and Dev Blog | Page 3",
    "headline": "Nick Liffen's Blog | Technology, DevOps and Dev Blog | Page 3",
    "description": "Nick Liffen's Blog | Focusing on DevOps, Developer Experience and all aspects of Technology",
    "datePublished": "2021-01-30",
    "dateModified": "2021-02-14",
    "keywords": [
        "Blog",
        "Technology",
        "DevOps",
        "Nick",
        "Liffen",
        "Developer",
        "GitHub"
    ],
    "url": "https://nickliffen.dev/articles/page/2.html",
    "author": {
        "@type": "Person",
        "name": "Nick Liffen"
    },
    "blogPosts": [
        {
        "@type": "BlogPosting",
        "name": "Nick Liffen's Blog | Building a Simple Website | Blog Post",
        "headline": "The importance of building a simple website and why",
        "description": "Nick Liffen's Blog | The importance of building a simple but effective website | Blog Post",
        "image": "https://nickliffen.dev/img/tech.jpg",
        "datePublished": "2021-01-23",
        "dateModified": "2021-01-31",
        "keywords": [
            "Websites",
            "Simple",
            "Accessibility",
            "Performance",
            "Best Practise"
        ],
        "articleSection": [
            "Context",
            "What I used",
            "What I learned from this experience"
        ],
        "articleBody": "This dates back to December 2020 over the Christmas break ...",
        "url": "https://nickliffen.dev/articles/building-a-simple-website.html",
        "author": {
            "@type": "Person",
            "name": "Nick Liffen"
        },
        "publisher": {
            "@type": "Person",
            "name": "Nick Liffen"
        }
        },
        {
        "@type": "BlogPosting",
        "@id": "https://nickliffen.dev/articles/review-ghas-code-scanning-enterprise.html",
        "name": "Nick Liffen Blog | Review of GitHub Code Scanning | Blog Post",
        "headline": "Review of GitHub Advanced Security Code Scanning in an Enterprise",
        "description": "Nick Liffen Blog | Review of GitHub Advanced Security Code Scanning in an Enterprise | Blog Post",
        "image": "https://nickliffen.dev/img/ghas.jpg",
        "datePublished": "2021-01-30",
        "dateModified": "2021-02-01",
        "keywords": [
            "GHAS",
            "GitHub Advanced Security",
            "Code Scanning",
            "Enterprise",
            "Nick Liffen"
        ],
        "url": "https://nickliffen.dev/articles/review-ghas-code-scanning-enterprise.html",
        "articleSection": [
            "Context",
            "What's Good",
            "What's Missing",
            "Concluding Thoughts"
        ],
        "articleBody": "GitHub recently introduced a suite of new products under ...",
        "author": {
            "@type": "Person",
            "name": "Nick Liffen"
        },
        "publisher": {
            "@type": "Person",
            "name": "Nick Liffen"
        }
        },
        {
        "@type": "BlogPosting",
        "@id": "https://nickliffen.dev/articles/centralised-vs-decentralised-devops.html",
        "name": "Nick Liffen's Blog | Centralised vs Decentralised DevOps | Blog Post",
        "headline": "Centralised vs Decentralised of a DevOps Toolchain within an Enterprise",
        "description": "Nick Liffen's Blog | Centralised vs Decentralised of a DevOps Toolchain within an Enterprise | Blog Post",
        "image": "https://nickliffen.dev/img/devops.png",
        "datePublished": "2021-02-07",
        "dateModified": "2021-02-307",
        "keywords": [
            "Nick",
            "Liffen",
            "JavaScript",
            "Blog",
            "DevOps",
            "Enterprise",
            "Centralised",
            "Decentralised"
        ],
        "articleSection": [
            "Context",
            "What does centralisation mean?",
            "What does decentralisation mean?",
            "So, what one should we pick?",
            "Conclusion"
        ],
        "articleBody": "To centralise or decentralise, that's the question.",
        "url": "https://nickliffen.dev/articles/centralised-vs-decentralised-devops.html",
        "author": {
            "@type": "Person",
            "name": "Nick Liffen"
        },
        "publisher": {
            "@type": "Person",
            "name": "Nick Liffen"
        }
        }
    ]
    }
</script>
</head>

<body>
  <a href="#main-content" class="skip-link" style="position:absolute;left:-10000px;top:auto;width:1px;height:1px;overflow:hidden;" onfocus="this.style.left='0';this.style.width='auto';this.style.height='auto';" onblur="this.style.left='-10000px';this.style.width='1px';this.style.height='1px';">Skip to main content</a>
  <div class="sidebar">
    <div class="container sidebar-sticky">
      <div class="sidebar-about">
        <h1>Nick Liffen</h1>
        <p class="lead">This is where I share my experiences</p>
      </div>
      <nav aria-label="Main navigation">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-item active">
          <a href="/">Home</a>
        </li>
        <li class="sidebar-nav-item">
          <a href="https://github.com/nickliffen">GitHub Profile</a>
        </li>
      </ul>
      </nav>
      <p>&copy; 2025. All rights reserved.</p>
    </div>
  </div>

  <main id="main-content" class="content container">
    <h1 class="center post-title mb">Table of Contents</h1>
    <div class="center mb">
      <div class="margin"><a href="../leadership-principles.html"> Leadership Principles: Guiding the Way to Success</a></div>
      <div class="margin"><a href="../why-advanced-security.html">Why Advanced Security?</a></div>
      <div class="margin"><a href="../developer-evolution.html">The Importance of Developer Experience - Developer roles are evolving!</a></div>
      <div class="margin"><a href="../step-functions.html">Coordinating a multi-lambda software product</a></div>
      <div class="margin"><a href="../innersourcing.html">An InnerSourcing Approach within an Enterprise</a></div>
      <div class="margin"><a href="../centralised-vs-decentralised-devops.html">Centralised vs Decentralised DevOps Toolchain - The Differences</a></div>
      <div class="margin"><a href="../review-ghas-code-scanning-enterprise.html">Review of GitHub Advanced Security Code Scanning in an Enterprise (Part 1)</a></div>
      <div class="margin"><a href="../building-a-simple-website.html">Building a simple website</a></div>
    </div>
    <hr class="rounded">
    <div class="posts">
      <div class="post">
        <h1 class="post-title mb">
          <a href="./articles/centralised-vs-decentralised-devops.html"> Centralised vs Decentralised DevOps Toolchain - The Differences </a>
        </h1>
        <span class="post-date">7th Feb 2021</span>
        <h2 id="context" class="mb">Context:</h2>
        <p>To centralise or decentralise, that's the question. When enterprises adopt DevOps, one of the most important considerations is how internal teams consume a toolchain supporting the DevOps mindset.</p>
        <p>In this article, I want to focus on the big question around how DevOps should (or could) be delivered within an enterprise. Should companies enable complete freedom and decentralisation of their toolchain and process? This lets teams put their own flavour on the core principles of DevOps. Or, do companies go for a more centralised route? This means more standardisation &amp; consistency across the enterprise and an easier adoption avenue due to central capabilities. Let's discuss the pros and cons of each and come up with a recommendation.</p>
        <h2 id="what-does-centralisation-mean" class="mb">What does centralisation mean?</h2>
        <p>Centralisation of DevOps tooling means offering a single toolchain and process for teams to follow across an enterprise. When you centralise, you provide multiple teams with a single avenue to adopt a DevOps mindset. There are many advantages to centralisation, some examples being:</p>
        <ul>
          <li><strong>Adoption:</strong> Whenever you centralise, you usually have a higher adoption percentage off the bat. This is mainly due to teams who are new to DevOps, more specifically, the tools that come as part of the DevOps toolchain, have a place to start and consume something <i>as a Service</i>. If you rely on teams standing up their own tooling, the time to adoption is generally longer as there is more setup time.</li>
          <li><strong>Consistency:</strong> If you centralise a process, an expected outcome of that is consistency. This means that if a developer is working on team X, and then moves to team Y; there is less "getting up to speed" time, as the processes would be the same for Team X and Team Y. This is a massive win if your company promotes rotation of developers and engineers across teams.</li>
          <li><strong>Time to Value:</strong> Application teams new to DevOps will find it quicker and easier to deploy something to production if you centralise. Teams spread across an enterprise can always ask questions to the central team owning DevOps, so someone is around to help out and ask questions. There is short term success here and a quicker time to value.</li>
        </ul>
        <p>As you can tell, there is a theme to the above. The newer your enterprise is to DevOps, the more value you will see from centralisation. However, there are some disadvantages or considerations to keep in mind.</p>
        <ul>
          <li><strong>Slow turnaround of Change:</strong> If only one team are allowed to own and maintain tools, and a customer puts in a feature request, that request may be one request often already in the backlog. As that customer who logged that bug, you may have to wait a month, even longer to see that feature request in production. Whereas if you had control of the tools in your application DevOps toolchain, you make the decisions, so the power is in your hands.</li>
          <li><strong>Reliance &amp; Excuses:</strong> If you centralise, it is easy for application teams to rely heavily on the team's who own the central tools. Especially if there is something the application team is waiting on. There is an excuse to why they are behind or not moving at the pace they should be, "I can't do this, just waiting for the central team to deliver something". Too much reliance on one team means you don't move at the pace that you may want to move at.</li>
        </ul>
        <p>There are lots of advantages to centralisation, especially for larger & legacy enterprises. Now let us discuss what decentralisation means.</p>
        <h2 id="what-does-decentralisation-mean" class="mb">What does decentralisation mean?</h2>
        <p>Decentralisation of DevOps tooling is the opposite of centralisation. It's where there is not central tooling, there is no central process, and you allow your enterprise to embrace the principles of DevOps themselves. There is a trust that they will see the value in DevOps, and have the creative and learning agile mindset to read, up-skill and apply. Some advantages of decentralisation are:</p>
        <ul>
          <li><strong>Embracing Diverse DevOps Models:</strong> There isn't one way to adopt DevOps, and there most certainly isn't one way to use a DevOps Toolchain. If you centralise too much, you will find people "doing the same thing" and not getting the most out of the tools that they are using.</li>
          <li><strong>Learning Agility:</strong> The value of decentralisation is that you are equipping your enterprise for learning success. Change has been, and always will be happening, especially within IT. If you fully decentralise, you are asking and almost enforcing your enterprise to upskill themselves. What this leads to is a longer-term success. If employees are used to changing and are used to learning new tools &amp; processes, anything new that comes up in the future should require less time to adopt as employees are used to a changing environment.</li>
          <li><strong>Innovation:</strong> This is a pivotal point to understand. You want your employees to be innovative and apply learnings to their working model. For some reason, there is a preconception that the centralised team knows best and what they say should go. This is not always the case. Just because the central team think they know what's right for the enterprise, doesn't mean they do. If you decentralise your DevOps process and toolchain, you are letting your employees innovate and think differently without the central team's restrictions. A different way of thinking about this is - would you rather a central team of 40 people making decisions, or would you like 1000 people (or everyone in your company) learning and deciding what's best. One thousand minds are better than 40.</li>
        </ul>
        <p>However, for all these advantages, there are possible disadvantages to think about:</p>
        <ul>
          <li><strong>Can be slow to get enterprise-wide adoption:</strong> Normally, leadership within an enterprise want quick results and want to see success straight away. If you have a highly skilled and learning agile company, this may not be so much of a problem. But companies who have been around a while may struggle with getting results quickly.</li>
          <li><strong>You may not see shared learnings:</strong> There is a reality to decentralisation: some teams will get it quicker than others. As there is no central team, there may not be an easy way to share learnings across teams. This will lead to some teams racing ahead of others, with the high likelihood some teams will never get it and will be left behind. At the end of the day you are one company, so the success shouldn't be perceived as team success, it should be company success. </li>
        </ul>
        <p>Similar to the centralisation section, there is a theme appearing. A newer company or a company with a highly agile culture is likely going to suit decentralisation more. I believe following this model will set yourself up for success longer-term; when done right.</p>
        <h2 id="what-one-should-we-pick" class="mb">So, what one should we pick?</h2>
        <p>The reality of this question is that there is no right answer. But there is a recommendation: </p>
        <p class="center"><strong>Centralise the DevOps Toolchain's foundations, whilst decentralising the journey on "how" teams adopt &amp; consume the centralised tools, patterns, and processes.</strong></p>
        <p>So, what does this mean? Let's break down that sentence into two:</p>
        <p class="center"><strong>"Centralise the DevOps Toolchain's foundations".</strong></p>
        <p>It isn't time effective, or cost-effective to have multiple of the same tools, or similar tools spread across an enterprise. An example being source code management. Stand up a single source code management tool and offer it out to the enterprise <i>as a Service</i>. This will reduce operational overhead because instead of multiple teams managing that tool; it will be supported and maintained centrally. Additionally, it's typically cheaper contractually if multiple licences are purchased centrally vs distributed across numerous contracts. For centralisation to be a success, automation and end-user autonomy needs to be a core principle. Staying with the source code management example mentioned above, you should allow customers to create repositories themselves without putting a request in and waiting. Allow teams to create teams themselves, as well as administer their own repository. Ensure there is no friction in the way of the customer of the tool. The more "red tape" and "friction" in the way of the customer and the centralised tool, the less chance of success. If you're thinking, "I can't give administration access and full autonomy in my company, we have quality process and regulations we need to meet." Just because you give autonomy and allow self-service, doesn't mean you can't wrap process and rigour around the tool, ensuring quality and security compliance. Use API's to build the needed quality processes to ensure the centralised tool is "in compliance" of any in-company procedures. Then publish documentation of any processes, so customers know what to expect. Mimic this for every tool within your toolchain.</p>
        <p>Additionally, understand that you will have different teams at different skill levels, so centralising foundational blueprints and patterns for teams to get started with makes sense. For example, within GitHub, create <a href="https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-template-repository">repository templates</a> which follow best practice (locked branches, pull requests enforced, turned on security tools). This means teams new to GitHub have a place to start "out of the box" with everything needed pre-created. The same goes for your CI/CD tool. Build reusable workflows/pipelines with standard testing &amp; deployment patterns across your enterprise. For example, you may be a predominately JavaScript shop, so building a single pipeline that does JavaScript testing/linting/security means teams new to CI/CD have a place to start (additionally teams with CI/CD experience may not want to build their own so will reuse what is on offer centrally). Thirdly, and finally, is the hosting platform chosen (AWS, Azure, GCP). Build central patterns for common software application architectures. e.g. if many of your software products built are web assets, creating a SPA template that comes with the needed infrastructure as code to deploy to AWS S3 & Cloud-front. This means teams have a place to start, especially people new to cloud-native. The same for API's would apply, an OpenAPI template that comes with AWS API Gateway & Lambda would be a great starter kit. </p>
        <p>Okay, so now you may be thinking wow this is a lot of centralisation, let's shift to the second part of the above phrase which is:</p>
        <p class="center"><strong>"Whilst decentralising the journey on "how" teams adopt &amp; consume the centralised tools, patterns, and processes." </strong></p>
        <p>You are not the police. You cannot dictate and enforce how teams use your tools. If you lock everything down to a single way of doing things, you will slow down teams. This will fail. Your company may have adopted a "DevOps Toolchain", but your teams won't be moving fast and won't be adopting the principles of DevOps. Past standing up the tools and foundational patterns/starter kits, let teams decide how they want to use the tools you have stood up.</p>
        <p>An example being your hosting platform. Stand up an underlying hosting service that meets the needed quality &amp; security processes for the enterprise, but then get out the application teams way. Do not centralise manual gates and reviews to one team as that team "they know best". </p>
        <p>Doing this will massively slow down not just deployment time, but learning time. Give autonomy for teams to deploy from Dev -> Q.A. -> Prod. If teams fail, that's okay, let them learn from that failure and apply that learning for next time. </p>
        <p>The same goes for CI/CD. In the above paragraph, I explained building example pipelines/workflows. Do not dictate this is the only way for teams to use CI/CD. Allow teams to see these as examples, and then customise to suit their needs. Teams may not even use these pre-built pipelines/workflows, and that's okay. They are there for reference and use if desired.</p>
        <p>The main point to be conveyed here is that there is no one way of doing things. Do not centralise the process, just the foundations and tools. Doing this will set teams up for success by themselves. Additionally, the more centralisation you do and the more is done for teams, the less they will learn themselves. This puts enterprises at a further disadvantage because if centralised tools change, or there is an update in a procedure that requires a change on the application team, teams will be foreign to doing things themselves, leading to slower change adoption.</p>
        <h2 id="conclusion" class="mb">Conclusion</h2>
        <p>There is a misconception that DevOps should be a specific role, and only people who's job title includes "DevOps" needs to focus on DevOps. In my opinion, this isn't, and shouldn't be the case. DevOps is a mindset (process) which teams need to adopt when building and deploying software products. Everyone part of that software team somewhat contributes to the DevOps process. As mentioned above, there is no right answer when it comes to centralisation or decentralisation, it depends on the company and most importantly, the people. In most enterprises, a mixture, or somewhere in-between centralisation/decentralisation, will give the best experience for different teams. To conclude, centralisation will get you quicker success but can be short term thinking. Decentralisation will take longer to get there but in the long term can see more significant benefits.</p>
        <p>The key takeaway though is centralisation works, but only when done at the correct level, and autonomy is vital.</p>
      </div>
      <hr class="rounded">
      <div class="post">
        <h1 class="post-title mb" id="ghas">
          <a href="../articles/review-ghas-code-scanning-enterprise.html"> Review of GitHub Advanced Security Code Scanning in an Enterprise (Part 1) </a>
        </h1>
        <span class="post-date">30th Jan 2021</span>
        <h2 id="context" class="mb">Context:</h2>
        <p>GitHub recently introduced a suite of new products under an overarching service called <a href="https://github.com/features/security" target="_blank" rel="noopener noreferrer">GitHub Advanced Security (GHAS)</a>. There are three core features as part of GHAS: <a href="https://docs.github.com/en/github/finding-security-vulnerabilities-and-errors-in-your-code/about-code-scanning" target="_blank" rel="noopener noreferrer"> Code Scanning</a>, <a href="https://docs.github.com/en/github/administering-a-repository/about-secret-scanning" rel="noopener noreferrer" target="_blank"> Secret Scanning</a> and <a href="https://docs.github.com/en/github/administering-a-repository/about-dependabot-version-updates" target="_blank" rel="noopener noreferrer"> Dependency Review</a>. In this article, I want to focus on what I would consider the core capability, Code Scanning.</p>
        <p>Code Scanning is a tool that allows developers to search for potential security vulnerabilities and coding errors in their code. People may compare this to static application security testing (SAST), or static analysis.</p>
        <p>This article assumes some background knowledge of GHAS Code Scanning. The core two sections will focus on what makes Code Scanning stand out amongst similar products and the challenges found so far within an enterprise. Meaning it's recommended reading the following links to get a brief understanding if you are unfamiliar:</p>
        <ul>
          <li class="margin"><a href="https://github.com/features/security" target="_blank" rel="noopener noreferrer"> Securing software, together</a></li>
          <li class="margin"><a href="https://www.youtube.com/watch?v=z0wvGf3O69E" target="_blank" rel="noopener noreferrer"> GitHub Code Scanning - your automated security PR review</a></li>
        </ul>
        <h2 id="whats-good" class="mb">What's good?</h2>
        <p>Critical features when enabling new tools and services within an enterprise are ease of use, and how simple it is for teams to get up and running. This is even more important when introducing new capabilities within the developer ecosystem. It needs to be seamlessly integrated into the developer workflow and configurable via code, not clicks. </p>
        <p>GHAS Code Scanning shines here, as all developers have to do is head to the security tab within a repository, click Setup this Workflow within the CodeQL card, and GitHub will auto-create a <code>codeql-analysis.yml</code> file. This file contains the process of running Code Scanning within your repository. The setup time per repository on average was 55 seconds. </p>
        <p>Furthermore, where GHAS Code Scanning starts to come into its element is its flexibility in configuration. As mentioned above, GitHub will auto-create a <code>code-analysis.yml</code> template, with GitHub being smart enough to detect repository languages and core branches (main, dev, etc.) and put these into the template automatically. However, the development team have complete control over how Code Scanning runs, meaning they can change the <code>code-analysis.yml</code> to meet there needs. A few examples being:</p>
        <ul>
          <li><strong>Triggers:</strong> Teams can decide what <a href="https://docs.github.com/en/github/finding-security-vulnerabilities-and-errors-in-your-code/configuring-code-scanning#configuring-frequency" target="_blank" rel="noopener noreferrer"> events</a> Code Scanning triggers on. E.G. Pull Request, Tags, Branches, and even cron jobs. A good tip is to configure Code Scanning to run on all pull requests, and then have a cron job running nightly on the default branch (which usually is your production build). Doing this means if any new security queriers get added to the CodeQL pack running on your repository, but you didn't make any commits to your default branch, the cron job will ensure you are kept updated with any new security vulnerabilities.</li>
          <li><strong>Auto Build Process:</strong> The way Code Scanning works is to auto-build your application (for compiled languages) automatically following standard build processes. This build process is all handled and abstracted for you using the <a href="https://github.com/github/codeql-action" target="_blank" rel="noopener noreferrer"> GitHub Action - Auto Build</a>. However, suppose your repository has some crazy build process which is entirely un-standard (yes, we all know a few of these applications). In that case, you can specify your application build process, and Code Scanning will honour it. Something that other security tools struggle with.</li>
          <li><strong>Configure the type of scan that suits you:</strong> This is one key feature which I believe goes under the radar. Different types of applications require different levels of acceptance of false positives. For example, if your application is lower risk, you only really want your security tooling to return vulnerabilities that are near 100% accurate. On the other hand, if your application is higher risk, your toleration of possible false positives is higher. GHAS Code Scanning allows you to tailor different "suites" of queries, dependent on your toleration level. If you don't specify a pack, the standard one will be run, which will only return high accuracy vulnerabilities. More information can be found in the following article: <a href="https://docs.github.com/en/github/finding-security-vulnerabilities-and-errors-in-your-code/configuring-code-scanning#running-additional-queries" target="_blank" rel="noopener noreferrer"> Running additional queries</a>. The value is enterprises has such a varied range of risk. Most security tools don't have a built-in feature that allows you to configure the type of scan to the application risk acceptance. GHAS Code Scanning changes the game in this aspect. </li>
        </ul>
        <p>It isn't just configuration flexibility that makes GHAS Code Scanning an excellent tool; it's the scans' speed. One of the problems seen previously is that scans could take 20-25 minutes when you had a polyglot repository. We found a dual language repository (JavaScript and Python) has an average scan time of 2 minutes and 11 seconds. As applications move to the cloud, and multi-language support becomes the norm, having a security tool that runs at a speed that falls in line with other CI/CD tools will be essential.</p>
        <p>The final point to touch on is the fact; it's GitHub. GitHub has built up such a good brand of delivering tooling that focuses on the developer, and we can't ignore that. Security tooling mostly has been very much focused on security, with the comprise of developer experience. GHAS Code Scanning so far has demonstrated that shouldn't be the case and doesn't have to be. There is a happy medium between developer autonomy and enabling a self-service nature, with security policies, processes and rigour.</p>
        <h2 id="whats-missing" class="mb">What's missing?</h2>
        <p>If you are reading this and thinking Code Scanning sounds like the tool for you, keep in mind that it's still a maturing tool with feature gaps. Some of the critical problems found so far are:</p>
        <ul>
          <li><strong>GitHub Contents API (No Support):</strong> One of the areas you may want to explore, to help teams adopt GHAS Code Scanning is building a tool that automatically creates a pull request on every repository with a template <code>code-analysis.yml</code> file. Doing this would enable two things, 1) reduce the time for teams to get up and running, as there is a template to get started with 2) encourage more teams to adopt GHAS, as there is an open pull request on their repository needed to be actioned. Both these areas lead to a better experience for application teams and a better security stance for the enterprise. The best way of doing this would be to use the <a href="https://docs.github.com/en/rest/reference/repos#contents" target="_blank" rel="noopener noreferrer">GitHub Contents API</a> to commit the template file. However, the <code>.github/workflows</code> directory (where the template needs to live) is protected from the Contents API, meaning it wouldn't work. GitHub says you need to use a native git client to perform any commits into the <code>.github/workflow</code> directory. The annoyance here is if you want to run this serverless, or without an underlying O.S., you can't. If you wanted to run this on AWS Lambda, you would need to do something like <a href="https://aws.amazon.com/blogs/aws/new-for-aws-lambda-container-image-support/" target="_blank" rel="noopener noreferrer"> Containers and Lambda</a>. Although this isn't architecturally a poor design, it's simpler to be consistent and use API commands only, versus having to use API calls and bash commands. When you think about unit testing, linting, etc., the moment you start writing bash, it becomes problematic. We overcame this by using the <a href="https://nodejs.org/api/child_process.html" target="_blank" rel="noopener noreferrer"> Child Process Module</a>. Overall, if this sounds like something you would be interested in, a tool has been built, and we are in the process of open-sourcing the codebase; I'll post back here when the repository is open. </li>
          <li><strong>Language Support:</strong> The <a href="https://docs.github.com/en/github/finding-security-vulnerabilities-and-errors-in-your-code/configuring-code-scanning#changing-the-languages-that-are-analyzed" target="_blank" rel="noopener noreferrer">languages</a> that GitHub support today are the most common, and when they support a language, it is thorough. However, key languages are missing that I would consider critical to support enterprises that likely has a diverse range of languages used. Examples being R, Swift, Kotlin and Rust. R is being used extensively across the statistical analysis and machine learning application world, so I expect to see GitHub support R in the next few languages released. I also hope to see Swift &amp; Kotlin support soon. Mobile apps are still essential, so interested to see support for mobile soon. </li>
          <li><strong>Permission Model:</strong> GitHub has to change the way permissions are currently handled with GHAS Code Scanning. Most enterprises need a way to add certain security personnel to repositories to monitor, action and closeout vulnerabilities found. Right now, to achieve this, they would have to be given some form of administrative access, which shouldn't be required. Creating a dedicated permission, focused purely on the security section, would allow that de-coupled responsibility away from other features, such as committing, maintaining, etc.</li>
          <li><strong>Connecting to the rest of the GitHub Ecosystem:</strong> GHAS Code Scanning still has minimal support when you think about how it connects with the wider GitHub Ecosystem. For example, the API support is minimal. There are no webhooks, so for large organisations with loads of repositories, this means lots of clicks. Additionally, there is no in-built way to reference vulnerabilities within GitHub Issues as you can with Pull Requests. I imagine a world where a vulnerability is found; a GitHub Issue is opened, and a conversation sparks between developers and security discussing vulnerability thoughts.</li>
        </ul>
        <p>These are the essential items, there are a few more, but if thinking about enabling GHAS, keep in mind the above gaps.</p>
        <h2 id="concluding-thoughts" class="mb">Concluding Thoughts</h2>
        <p>I genuinely believe GHAS Code Scanning has the foundation and vision to become a leader within the security space, whilst ensuring developer experience stays a core principle. Code Scanning is built directly into GitHub, which means developers find it easy to locate results and therefore action them. This is a primary behaviour any enterprise wants when introducing a new security tool. I am excited to see Code Scanning mature over the coming months and years. I believe the roadmap is strong. To conclude, GHAS Code Scanning can disrupt the developer ecosystem's security tooling space with the right push from the open-source and enterprise community's. Watch this space!</p>
        <p><i>I plan to update this blog as new features come out, and the service grows. Part 2 and Part 3 will come in the coming months focused on Secret Scanning &amp; Dependency Reviews.</i></p>
      </div>
      <hr class="rounded">
      <div class="post">
        <h1 class="post-title mb" id="websimple">
          <a href="../building-a-simple-website.html"> Building a simple website </a>
        </h1>
        <span class="post-date">21st Jan 2021</span>
        <h2 id="context-simple-website" class="mb">Context:</h2>
        <p> This dates back to December 2020 over the Christmas break when I decided it would be a good idea to start my own technology blog. It is something I have been doing myself for the last few years, but never published publicly. I am lucky enough to work for a company and a role, that gives me opportunities to work with diverse teams (from a technology perspective), meaning I am in a unique position where I see a broad range of technologies and how technology is applied/adopted. My role is leading DevOps &amp; Developer Experience globally for a company called <a href="https://www.lilly.com/" target="_blank" rel="noopener noreferrer"> Lilly</a>. Most of my day-to-day tasks involve improving developer momentum and building a community for developers to be successful. This blog represents my thoughts only, and no way represents the company's thoughts that I work for. </p>
        <p> This leads me to this website, and the importance of this article's title, building a simple website. </p>
        <h2 id="what-i-used-simple-website" class="mb">What I used:</h2>
        <p> "What I used" is somewhat the most crucial section, as it walks through the journey that I went on for building this website and why building "simple" is so important. </p>
        <p> JavaScript is by far my most comfortable language, and <a href="https://vuejs.org/" target="_blank" rel="noopener noreferrer"> VueJS</a> being my go-to front end framework. So naturally, I started there. It didn't take me long to have a simple blueprint in place. </p>
        <p> I started by using the <a href="https://github.com/chrisvfritz/vue-enterprise-boilerplate" target="_blank" rel="noopener noreferrer"> VueJS Enterprise Boilerplate</a>, that comes with some great tools and utils out of the box, and a stable build process with <a href="https://nuxtjs.org/"> Nuxt</a>. I built on-top of this blueprint, adding some simple components and style that made my application look like a blog. I was getting ready to publish when my DevOps side came out and thought I should run my blog through <a href="https://developers.google.com/web/tools/lighthouse" target="_blank" rel="noopener noreferrer"> lighthouse</a> to check performance, accessibility and best practice. The results were poor, </p>
        <ul>
          <li>Accessibility was at 65%.</li>
          <li>Performance was at 71%.</li>
          <li>Best Practise was 73%.</li>
        </ul>
        <p> The scores above came down to the application having so much going on. Specifically, the performance score was low for a few reasons. A few being: The network payload was 12,210kb, the JavaScript execution time was 1.9 seconds, and the DOM contained 210 elements! I spent a few hours fine-tuning the bundle, reducing a lot of JavaScript "bloat" that wasn't needed, and that did help improve the score, but that made me pause, take a step back, and think, why am I doing this. Why am I spending time fine-tuning an application, with so much bloat, that just shouldn't be needed for my use case? I wanted to build a site where I can share my experiences with others in a comfortable and consumable way. I was overcomplicating the simple. Taking a look at my code base, it already had over 40 files (a lot of these being configuration files, obviously), and the total LOC came over 3000 lines (ignoring the package-lock file). I only had 1 blog post. </p>
        <p> This was when I decided to go back to basics and go "old school" with a simple, static HTML and CSS site. Fast forward 55 minutes, I had a simple website built, that meet my use case. The only technologies I used was HTML &amp; CSS, I had no JS, as it just wasn't needed. When running it through lighthouse again, the difference was insane:  </p>
        <ul>
          <li>Accessibility was at 95%.</li>
          <li>Performance was at 100%.</li>
          <li>Best Practise was 100%.</li>
        </ul>
        <p> The network payload was under 1,000kb, the JavaScript execution time went down to 0.4 seconds, and the DOM size was minimal. In all, there was just so much less pressure on the browser. The number of files totalled 19, and my overall LOC come out under 500 lines. I spent about 20 minutes fine-tuning, but that it. </p>
        <h2 id="what-i-learned-from-this-experience-simple-website" class="mb">What I learned from this experience:</h2>
        <p> What have I learnt from this? In a few words, simplicity is vital. Always think about your use case and what you need to build. Ask yourself, what is the most straightforward path I can take to achieve success. Now, I agree that nowadays, personalised experiences are vital, and dynamic content is the norm. This naturally means front end frameworks like VueJS, React, etc. are the standard and the "go-to". This theory showed as my "go-to" for building this website was VueJS. I didn't even think of anything else, mostly plain HTML. But this isn't, and shouldn't always be the case. I recognise that instead of thinking about the product I was building, my focus went straight to the technology and what I was going to use. </p>
        <p> To conclude, building this website has actually been fun. It has made me go back to my roots and write some vanilla HTML. It has made me realise I rely too heavily on third-party frameworks. Finally, it has made me realise that building a performant and optimal website is made easy by starting simple. If this blog expands, moving to a more progressive &amp; dynamic application may be needed, but for now, my simple design meets what I needed to build. </p>
      </div>
    </div>
    <div class="pagination">
      <a href ="/articles/page/2.html"><span class="pagination-item older">Older</span></a>
      <span class="pagination-item newer">Newer</span>
    </div>
    </main>
</body>

</html>
